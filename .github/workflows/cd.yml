name: Deploy (Production) via SSH

# 1. Configura o gatilho para rodar sempre que houver um push para o branch 'main'
on:
  push:
    branches:
      - main
  workflow_dispatch: # Permite acionamento manual no GitHub

# Define as vari√°veis de ambiente base para uso interno no workflow
env:
  PROJECT_PATH: /root/Avalia-Solar-2026

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    # Adiciona a condi√ß√£o para garantir que o deploy s√≥ ocorra se todos os Secrets estiverem configurados
    environment:
      name: production
    
    steps:
      - name: Checkout C√≥digo
        uses: actions/checkout@v4

      # ‚öôÔ∏è 1. Configurar Vari√°veis de Ambiente no Droplet (M√©todo printf)
      - name: Injetar Segredos e Chaves no Arquivo .env
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "--- Configurando .env no servidor ---"
            cd ${{ env.PROJECT_PATH }}
            
            # Limpa o arquivo .env para reescrita
            > .env 
            
            # Escreve as vari√°veis de ambiente no formato Shell (ENV=VALOR)
            printf "RAILS_ENV=production\n" >> .env
            printf "PORT=3001\n" >> .env
            printf "RAILS_LOG_TO_STDOUT=true\n" >> .env
            printf "RAILS_SERVE_STATIC_FILES=true\n" >> .env
            
            # Vari√°veis de Seguran√ßa (Usando Secrets)
            printf "RAILS_MASTER_KEY=%s\n" "${{ secrets.RAILS_MASTER_KEY }}" >> .env
            printf "SECRET_KEY_BASE=%s\n" "${{ secrets.SECRET_KEY_BASE }}" >> .env
            printf "JWT_SECRET=%s\n" "${{ secrets.JWT_SECRET }}" >> .env
            
            # Vari√°veis do Postgres (Usando Secrets)
            printf "POSTGRES_USER=%s\n" "${{ secrets.POSTGRES_USER }}" >> .env
            printf "POSTGRES_PASSWORD=%s\n" "${{ secrets.POSTGRES_PASSWORD }}" >> .env
            printf "POSTGRES_DB=%s\n" "${{ secrets.POSTGRES_DB }}" >> .env
            
            # DATABASE_URL (montada com host 'db' para Docker Compose)
            printf "DATABASE_URL=postgresql://%s:%s@db:5432/%s\n" \
                "${{ secrets.POSTGRES_USER }}" \
                "${{ secrets.POSTGRES_PASSWORD }}" \
                "${{ secrets.POSTGRES_DB }}" >> .env
            
            # Outras Vari√°veis
            printf "REDIS_URL=redis://redis:6379/0\n" >> .env
            printf "NEXT_PUBLIC_API_URL=https://api.avaliasolar.com.br/api/v1\n" >> .env
            printf "CORS_ORIGINS=https://avaliasolar.com.br,https://www.avaliasolar.com.br\n" >> .env

            # Define permiss√µes seguras
            chmod 600 .env
            echo '‚úÖ Arquivo .env criado/atualizado com sucesso.'

      # üêã 2. Deploy e Inicializa√ß√£o (Build, Setup DB, Up)
      - name: Executar Build e Setup do Banco de Dados
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "--- 1. Puxando C√≥digo e Reconstruindo Imagens ---"
            cd ${{ env.PROJECT_PATH }}

            # Puxa as √∫ltimas altera√ß√µes do c√≥digo (incluindo Company.rb corrigido)
            git pull origin main

            # Reconstru√ß√£o das imagens (backend e frontend)
            docker-compose build --no-cache

            echo "--- 2. Setup do Banco de Dados (Cria√ß√£o e Migra√ß√£o) ---"
            
            # (O docker-compose down --volumes j√° foi executado na primeira vez,
            # agora focamos no setup limpo ap√≥s o build)
            
            # Garante que os servi√ßos de infra estejam rodando
            docker-compose up -d db redis frontend

            # Aguarda o DB iniciar (Healthcheck)
            sleep 15 

            # CRIA/MIGRA O BANCO DE DADOS E RODA SEEDS DE FORMA LIMPA:
            # Isso resolve o problema de estado inconsistente (DuplicateColumn)
            docker-compose run --rm backend bundle exec rake db:create db:migrate
            
            echo "--- 3. Rodando Seeds ---"
            docker-compose run --rm backend bundle exec rake db:seed

            echo "--- 4. Subindo o Backend Final ---"
            # Inicia o cont√™iner principal do backend
            docker-compose up -d backend
            
            echo "üéâ DEPLOY CONCLU√çDO COM SUCESSO!"
            docker-compose ps